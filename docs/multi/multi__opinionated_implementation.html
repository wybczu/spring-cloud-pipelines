<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>3.&nbsp;Opinionated Implementation</title><link rel="stylesheet" type="text/css" href="css/manual-multipage.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="multi_spring-cloud-pipelines.html" title="Spring Cloud Pipelines"><link rel="up" href="multi__spring_cloud_pipelines.html" title="Part&nbsp;I.&nbsp;Spring Cloud Pipelines"><link rel="prev" href="multi_how-do-the-scripts-work.html" title="2.&nbsp;How the Scripts Work"><link rel="next" href="multi_project-opinions.html" title="4.&nbsp;Project Opinions"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">3.&nbsp;Opinionated Implementation</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="multi_how-do-the-scripts-work.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;I.&nbsp;Spring Cloud Pipelines</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="multi_project-opinions.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_opinionated_implementation" href="#_opinionated_implementation"></a>3.&nbsp;Opinionated Implementation</h2></div></div></div><p>This section describes a full flow of the demo applications.</p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top"><p>Your applications need not have the same dependencies (such as <code class="literal">Eureka</code>) as this demo.</p></td></tr></table></div><p>For demo purposes, we provide Docker Compose setup with Artifactory, Concourse, and Jenkins tools.
Regardless of the CD application, for the pipeline to pass, you need one of the following:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">A Cloud Foundry instance (for example, <a class="link" href="https://run.pivotal.io/" target="_top">Pivotal Web Services</a> or <a class="link" href="https://pivotal.io/pcf-dev" target="_top">PCF Dev</a>).</li><li class="listitem">A Kubernetes cluster (for example, <a class="link" href="https://github.com/kubernetes/minikube" target="_top">Minikube</a>).</li><li class="listitem">The infrastructure applications deployed to the JAR hosting application (for the demo, we provide Artifactory).</li><li class="listitem"><code class="literal">Eureka</code> for Service Discovery.</li><li class="listitem"><code class="literal">Stub Runner Boot</code> for running Spring Cloud Contract stubs.</li></ul></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>In the demos, we show you how to first build the <code class="literal">github-webhook</code> project. That is because
the <code class="literal">github-analytics</code> needs the stubs of <code class="literal">github-webhook</code> to pass the tests. We also use
references to the <code class="literal">github-analytics</code> project, since it contains more interesting pieces as far as testing
is concerned.</p></td></tr></table></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_build" href="#_build"></a>3.1&nbsp;Build</h2></div></div></div><p>The following image shows the results of building the demo pipeline (which the rest of this chapter describes):</p><div class="figure"><a name="d0e945" href="#d0e945"></a><p class="title"><b>Figure&nbsp;3.1.&nbsp;Build and upload artifacts</b></p><div class="figure-contents"><div class="mediaobject"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-pipelines/master/docs-sources/src/main/asciidoc/images/intro/build.png" alt="build"></div></div></div><br class="figure-break"><p>In this step, we  generate a version of the pipeline. Next, we
run unit, integration, and contract tests. Finally, we:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Publish a fat jar of the application.</li><li class="listitem">Publish a Spring Cloud Contract jar containing stubs of the application.</li><li class="listitem">For Kubernetes, upload a Docker image of the application.</li></ul></div><p>During this phase, we run a <code class="literal">Maven</code> build by using Maven Wrapper or a <code class="literal">Gradle</code> build by using Gradle Wrapper,
with unit and integration tests. We also tag the repository with <code class="literal">dev/${version}</code>. That way, in each
subsequent step of the pipeline, we can retrieve the tagged version. Also, we know
exactly which version of the pipeline corresponds to which Git hash.</p><p>Once the artifact is built, we run API compatibility check, as follows:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">We search for the latest production deployment.</li><li class="listitem">We retrieve the contracts that were used by that deployment.</li><li class="listitem">From the contracts, we generat API tests to see if the current implementation
is fulfilling the HTTP and messaging contracts that the current production deployment
has defined (we check backward compatibility of the API).</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_test" href="#_test"></a>3.2&nbsp;Test</h2></div></div></div><p>The following image shows the result of doing smoke tests and rolling back:</p><div class="figure"><a name="d0e994" href="#d0e994"></a><p class="title"><b>Figure&nbsp;3.2.&nbsp;Smoke test and rollback test on test environment</b></p><div class="figure-contents"><div class="mediaobject"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-pipelines/master/docs-sources/src/main/asciidoc/images/intro/test.png" alt="test"></div></div></div><br class="figure-break"><p>Here, we:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Start a RabbitMQ service in PaaS.</li><li class="listitem">Deploying <code class="literal">Eureka</code> infrastructure application to PaaS.</li><li class="listitem">Download the fat jar from Nexus and upload it to PaaS. We want the application
to run in isolation (be surrounded by stubs).</li></ul></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>Currently, due to port constraints in Cloud Foundry,
we cannot run multiple stubbed HTTP services in the cloud. To fix this issue, we run
the application with the <code class="literal">smoke</code> Spring profile, on which you can stub out all HTTP calls to return
a mocked response.</p></td></tr></table></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">If the application uses a database, it gets upgraded at this point by Flyway, Liquibase,
or any other migration tool once the application gets started.</li><li class="listitem">From the project&#8217;s Maven or Gradle build, we extract the <code class="literal">stubrunner.ids</code> property that contains
all the <code class="literal">groupId:artifactId:version:classifier</code> notations of dependent projects for which
the stubs should be downloaded.</li><li class="listitem">We upload <code class="literal">Stub Runner Boot</code> and pass the extracted <code class="literal">stubrunner.ids</code> to it. That way,
we have a running application in Cloud Foundry that downloads all the necessary stubs
of our application.</li><li class="listitem">From the checked-out code, we run the tests available under the <code class="literal">smoke</code> profile. In the
case of the <code class="literal">GitHub Analytics</code> application, we trigger a message from the <code class="literal">GitHub Webhook</code>
application&#8217;s stub and send the message by RabbitMQ to GitHub Analytics. Then we check whether the
message count has increased.</li><li class="listitem">Once the tests pass, we search for the last production release. Once the application
is deployed to production, we tag it with <code class="literal">prod/${version}</code>. If there is no such tag
(there was no production release), no rollback tests are run. If there was
a production release, the tests get executed.</li><li class="listitem">Assuming that there was a production release, we check out the code that corresponds to that
release (we check out the tag), download the appropriate artifact (either a JAR for Cloud Foundry
or a Docker image for Kubernetes), and we upload
it to PaaS.</li></ul></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top"><p>The old artifact runs against the <span class="strong"><strong>NEW</strong></span> version of the database.</p></td></tr></table></div><p>We run the old <code class="literal">smoke</code> tests against the freshly deployed application, surrounded by stubs.
If those tests pass, we have a high probability that the application is backwards compatible.
* The default behavior is that, after all of those steps, the user can manually click to deploy the
application to a stage environment.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_stage" href="#_stage"></a>3.3&nbsp;Stage</h2></div></div></div><p>The following image shows the result of deploying to a stage environment:</p><div class="figure"><a name="d0e1083" href="#d0e1083"></a><p class="title"><b>Figure&nbsp;3.3.&nbsp;End to end tests on stage environment</b></p><div class="figure-contents"><div class="mediaobject"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-pipelines/master/docs-sources/src/main/asciidoc/images/intro/stage.png" alt="stage"></div></div></div><br class="figure-break"><p>Here, we:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Start a RabbitMQ service in PaaS.</li><li class="listitem">Deploy <code class="literal">Eureka</code> infrastructure application to PaaS.</li><li class="listitem">Download the artifact (either a JAR for Cloud Foundry or a Docker image for Kubernetes)
upload it to PaaS.</li></ul></div><p>Next, we have a manual step in which, from the checked-out code, we run the tests available under the <code class="literal">e2e</code> profile. In the
case of the <code class="literal">GitHub Analytics</code> application, we send an HTTP message to the GitHub Analytics endpoint. Then we check whether
the received message count has increased.</p><p>By default, this step is manual, because the stage environment is often shared between
teams and some preparations on databases and infrastructure have to take place before the tests can be run.
Ideally, these step should be fully automatic.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_prod" href="#_prod"></a>3.4&nbsp;Prod</h2></div></div></div><p>The following image shows the result of deploying to a production environment:</p><div class="figure"><a name="d0e1122" href="#d0e1122"></a><p class="title"><b>Figure&nbsp;3.4.&nbsp;Deployment to production</b></p><div class="figure-contents"><div class="mediaobject"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-pipelines/master/docs-sources/src/main/asciidoc/images/intro/prod.png" alt="prod"></div></div></div><br class="figure-break"><p>The step to deploy to production is manual. However, ideally, it should be automatic.</p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top"><p>This step does deployment to production. On production, we assume
that you have the infrastructure running. That is why, before you run this step, you
must run a script that provisions the services on the production environment.
For <code class="literal">Cloud Foundry</code>, call <code class="literal">tools/cf-helper.sh setup-prod-infra</code>.
For Kubernetes, call <code class="literal">tools/k8s-helper.sh setup-prod-infra</code>.</p></td></tr></table></div><p>Here, we:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Tag the Git repo with <code class="literal">prod/${version}</code>.</li><li class="listitem">Download the application artifact (either a JAR for Cloud Foundry or a Docker image for Kubernetes).</li><li class="listitem"><p class="simpara">We do Blue Green deployment:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p class="simpara">For Cloud Foundry:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem">We rename the current instance of the application (for example, <code class="literal">myService</code> to <code class="literal">myService-venerable</code>).</li><li class="listitem">We deploy the new instance of the app under the <code class="literal">fooService</code> name</li><li class="listitem">Now, two instances of the same application are running on production.</li></ul></div></li><li class="listitem"><p class="simpara">For Kubernetes:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem">We deploy a service with the name of the application (for example, <code class="literal">myService</code>)</li><li class="listitem">We do a deployment with the name of the application with version suffix,with the name escaped
to fulfill the DNS name requirements (for example, <code class="literal">fooService-1-0-0-M1-123-456-VERSION</code>).</li><li class="listitem">All deployments of the same application have the same label <code class="literal">name</code>, which is equal to the application name (for example, <code class="literal">myService</code>).</li><li class="listitem">The service routes the traffic by basing on the <code class="literal">name</code> label selector.</li><li class="listitem">Now two instances of the same application are running in production.</li></ul></div></li></ul></div></li><li class="listitem"><p class="simpara">In the <code class="literal">Complete switch over</code>, which is a manual step, we stop the old instance.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Remember to run this step only after you have confirmed that both instances work.</p></td></tr></table></div></li><li class="listitem"><p class="simpara">In the <code class="literal">Rollback</code>, which is a manual step,</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p class="simpara">We route all the traffic to the old instance.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem">In CF, we do that by ensuring that blue is running and removing green.</li><li class="listitem">In K8S, we do that by scaling the number of instances of green to 0.</li></ul></div></li><li class="listitem">We remov the latest prod Git tag.</li></ul></div></li></ul></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="multi_how-do-the-scripts-work.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="multi__spring_cloud_pipelines.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="multi_project-opinions.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">2.&nbsp;How the Scripts Work&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="multi_spring-cloud-pipelines.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;4.&nbsp;Project Opinions</td></tr></table></div></body></html>